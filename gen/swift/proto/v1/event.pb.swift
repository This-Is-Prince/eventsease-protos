// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/v1/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Eventsease_V1_SortBy: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case startDate // = 1
  case createdDate // = 2
  case heartCount // = 3
  case savedCount // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .startDate
    case 2: self = .createdDate
    case 3: self = .heartCount
    case 4: self = .savedCount
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .startDate: return 1
    case .createdDate: return 2
    case .heartCount: return 3
    case .savedCount: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Eventsease_V1_SortBy] = [
    .unspecified,
    .startDate,
    .createdDate,
    .heartCount,
    .savedCount,
  ]

}

public enum Eventsease_V1_SortDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case asc // = 1
  case desc // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .asc
    case 2: self = .desc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .asc: return 1
    case .desc: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Eventsease_V1_SortDirection] = [
    .unspecified,
    .asc,
    .desc,
  ]

}

public enum Eventsease_V1_SocialType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case phone // = 1
  case instagram // = 2
  case facebook // = 3
  case whatsapp // = 4
  case website // = 5
  case email // = 6
  case twitter // = 7
  case linkedin // = 8
  case youtube // = 9
  case other // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .phone
    case 2: self = .instagram
    case 3: self = .facebook
    case 4: self = .whatsapp
    case 5: self = .website
    case 6: self = .email
    case 7: self = .twitter
    case 8: self = .linkedin
    case 9: self = .youtube
    case 10: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .phone: return 1
    case .instagram: return 2
    case .facebook: return 3
    case .whatsapp: return 4
    case .website: return 5
    case .email: return 6
    case .twitter: return 7
    case .linkedin: return 8
    case .youtube: return 9
    case .other: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Eventsease_V1_SocialType] = [
    .unspecified,
    .phone,
    .instagram,
    .facebook,
    .whatsapp,
    .website,
    .email,
    .twitter,
    .linkedin,
    .youtube,
    .other,
  ]

}

public struct Eventsease_V1_Event: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var slug: String {
    get {return _storage._slug}
    set {_uniqueStorage()._slug = newValue}
  }

  public var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  public var hasStartDate: Bool {return _storage._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  public mutating func clearStartDate() {_uniqueStorage()._startDate = nil}

  public var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  public var hasEndDate: Bool {return _storage._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  public mutating func clearEndDate() {_uniqueStorage()._endDate = nil}

  public var location: Eventsease_V1_Location {
    get {return _storage._location ?? Eventsease_V1_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  public var eventPhotos: [String] {
    get {return _storage._eventPhotos}
    set {_uniqueStorage()._eventPhotos = newValue}
  }

  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var organizer: String {
    get {return _storage._organizer}
    set {_uniqueStorage()._organizer = newValue}
  }

  public var category: String {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var ticketInfo: Eventsease_V1_TicketInfo {
    get {return _storage._ticketInfo ?? Eventsease_V1_TicketInfo()}
    set {_uniqueStorage()._ticketInfo = newValue}
  }
  /// Returns true if `ticketInfo` has been explicitly set.
  public var hasTicketInfo: Bool {return _storage._ticketInfo != nil}
  /// Clears the value of `ticketInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTicketInfo() {_uniqueStorage()._ticketInfo = nil}

  public var social: [Eventsease_V1_SocialLink] {
    get {return _storage._social}
    set {_uniqueStorage()._social = newValue}
  }

  public var isPaid: Bool {
    get {return _storage._isPaid}
    set {_uniqueStorage()._isPaid = newValue}
  }

  public var isApproved: Bool {
    get {return _storage._isApproved}
    set {_uniqueStorage()._isApproved = newValue}
  }

  public var isRegular: Bool {
    get {return _storage._isRegular}
    set {_uniqueStorage()._isRegular = newValue}
  }

  public var heartCount: Int32 {
    get {return _storage._heartCount}
    set {_uniqueStorage()._heartCount = newValue}
  }

  public var savedCount: Int32 {
    get {return _storage._savedCount}
    set {_uniqueStorage()._savedCount = newValue}
  }

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var isPinned: String {
    get {return _storage._isPinned}
    set {_uniqueStorage()._isPinned = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Eventsease_V1_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var lat: Double = 0

  public var lng: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_TicketInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isFree: Bool = false

  public var entryFee: Double = 0

  public var earlyBirdFee: Double = 0

  public var isAppointmentBased: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_SocialLink: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Eventsease_V1_SocialType = .unspecified

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_GetEventsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var region: Eventsease_V1_Region {
    get {return _region ?? Eventsease_V1_Region()}
    set {_region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return self._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {self._region = nil}

  public var categories: [String] = []

  public var date: String = String()

  public var sortBy: Eventsease_V1_SortBy = .unspecified

  public var sortDirection: Eventsease_V1_SortDirection = .unspecified

  public var searchQuery: String = String()

  public var isRegular: Bool = false

  public var page: Int32 = 0

  public var limit: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _region: Eventsease_V1_Region? = nil
}

public struct Eventsease_V1_Region: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var latitude: Double = 0

  public var longitude: Double = 0

  public var latitudeDelta: Double = 0

  public var longitudeDelta: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_GetEventsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var data: [Eventsease_V1_Event] = []

  public var meta: Eventsease_V1_MetaData {
    get {return _meta ?? Eventsease_V1_MetaData()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  public var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  public mutating func clearMeta() {self._meta = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _meta: Eventsease_V1_MetaData? = nil
}

public struct Eventsease_V1_MetaData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalCount: Int64 = 0

  public var totalPages: Int64 = 0

  public var currentPage: Int32 = 0

  public var limit: Int32 = 0

  public var hasNextPage_p: Bool = false

  public var hasPreviousPage_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_GetEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idOrSlug: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_GetEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var data: Eventsease_V1_Event {
    get {return _data ?? Eventsease_V1_Event()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Eventsease_V1_Event? = nil
}

public struct Eventsease_V1_CreateEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: Eventsease_V1_Event {
    get {return _event ?? Eventsease_V1_Event()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _event: Eventsease_V1_Event? = nil
}

public struct Eventsease_V1_CreateEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var message: String = String()

  public var data: Eventsease_V1_Event {
    get {return _data ?? Eventsease_V1_Event()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Eventsease_V1_Event? = nil
}

public struct Eventsease_V1_GetEventStatsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_GetEventStatsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var data: Eventsease_V1_EventStats {
    get {return _data ?? Eventsease_V1_EventStats()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Eventsease_V1_EventStats? = nil
}

public struct Eventsease_V1_EventStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var heartCount: Int32 = 0

  public var savedCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_GetUserEventsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: Int32 = 0

  public var limit: Int32 = 0

  public var searchQuery: String = String()

  public var sortBy: Eventsease_V1_SortBy = .unspecified

  public var sortDirection: Eventsease_V1_SortDirection = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_ToggleSavedEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Eventsease_V1_ToggleSavedEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var isSaved: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "eventsease.v1"

extension Eventsease_V1_SortBy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SORT_BY_UNSPECIFIED\0\u{1}SORT_BY_START_DATE\0\u{1}SORT_BY_CREATED_DATE\0\u{1}SORT_BY_HEART_COUNT\0\u{1}SORT_BY_SAVED_COUNT\0")
}

extension Eventsease_V1_SortDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SORT_DIRECTION_UNSPECIFIED\0\u{1}SORT_DIRECTION_ASC\0\u{1}SORT_DIRECTION_DESC\0")
}

extension Eventsease_V1_SocialType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SOCIAL_TYPE_UNSPECIFIED\0\u{1}SOCIAL_TYPE_PHONE\0\u{1}SOCIAL_TYPE_INSTAGRAM\0\u{1}SOCIAL_TYPE_FACEBOOK\0\u{1}SOCIAL_TYPE_WHATSAPP\0\u{1}SOCIAL_TYPE_WEBSITE\0\u{1}SOCIAL_TYPE_EMAIL\0\u{1}SOCIAL_TYPE_TWITTER\0\u{1}SOCIAL_TYPE_LINKEDIN\0\u{1}SOCIAL_TYPE_YOUTUBE\0\u{1}SOCIAL_TYPE_OTHER\0")
}

extension Eventsease_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Event"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}description\0\u{1}slug\0\u{3}start_date\0\u{3}end_date\0\u{1}location\0\u{3}event_photos\0\u{3}user_id\0\u{1}organizer\0\u{1}category\0\u{3}ticket_info\0\u{1}social\0\u{3}is_paid\0\u{3}is_approved\0\u{3}is_regular\0\u{3}heart_count\0\u{3}saved_count\0\u{3}created_at\0\u{3}updated_at\0\u{3}is_pinned\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _description_p: String = String()
    var _slug: String = String()
    var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _location: Eventsease_V1_Location? = nil
    var _eventPhotos: [String] = []
    var _userID: String = String()
    var _organizer: String = String()
    var _category: String = String()
    var _ticketInfo: Eventsease_V1_TicketInfo? = nil
    var _social: [Eventsease_V1_SocialLink] = []
    var _isPaid: Bool = false
    var _isApproved: Bool = false
    var _isRegular: Bool = false
    var _heartCount: Int32 = 0
    var _savedCount: Int32 = 0
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isPinned: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _description_p = source._description_p
      _slug = source._slug
      _startDate = source._startDate
      _endDate = source._endDate
      _location = source._location
      _eventPhotos = source._eventPhotos
      _userID = source._userID
      _organizer = source._organizer
      _category = source._category
      _ticketInfo = source._ticketInfo
      _social = source._social
      _isPaid = source._isPaid
      _isApproved = source._isApproved
      _isRegular = source._isRegular
      _heartCount = source._heartCount
      _savedCount = source._savedCount
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _isPinned = source._isPinned
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._slug) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startDate) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._endDate) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._eventPhotos) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._organizer) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._category) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._ticketInfo) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._social) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isPaid) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isApproved) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isRegular) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._heartCount) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._savedCount) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._isPinned) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if !_storage._slug.isEmpty {
        try visitor.visitSingularStringField(value: _storage._slug, fieldNumber: 4)
      }
      try { if let v = _storage._startDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._endDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._eventPhotos.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._eventPhotos, fieldNumber: 8)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 9)
      }
      if !_storage._organizer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._organizer, fieldNumber: 10)
      }
      if !_storage._category.isEmpty {
        try visitor.visitSingularStringField(value: _storage._category, fieldNumber: 11)
      }
      try { if let v = _storage._ticketInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._social.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._social, fieldNumber: 13)
      }
      if _storage._isPaid != false {
        try visitor.visitSingularBoolField(value: _storage._isPaid, fieldNumber: 14)
      }
      if _storage._isApproved != false {
        try visitor.visitSingularBoolField(value: _storage._isApproved, fieldNumber: 15)
      }
      if _storage._isRegular != false {
        try visitor.visitSingularBoolField(value: _storage._isRegular, fieldNumber: 16)
      }
      if _storage._heartCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._heartCount, fieldNumber: 17)
      }
      if _storage._savedCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._savedCount, fieldNumber: 18)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._isPinned.isEmpty {
        try visitor.visitSingularStringField(value: _storage._isPinned, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_Event, rhs: Eventsease_V1_Event) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._slug != rhs_storage._slug {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._endDate != rhs_storage._endDate {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._eventPhotos != rhs_storage._eventPhotos {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._organizer != rhs_storage._organizer {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._ticketInfo != rhs_storage._ticketInfo {return false}
        if _storage._social != rhs_storage._social {return false}
        if _storage._isPaid != rhs_storage._isPaid {return false}
        if _storage._isApproved != rhs_storage._isApproved {return false}
        if _storage._isRegular != rhs_storage._isRegular {return false}
        if _storage._heartCount != rhs_storage._heartCount {return false}
        if _storage._savedCount != rhs_storage._savedCount {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._isPinned != rhs_storage._isPinned {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Location"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}address\0\u{1}lat\0\u{1}lng\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.lng) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 2)
    }
    if self.lng.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lng, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_Location, rhs: Eventsease_V1_Location) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.lng != rhs.lng {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_TicketInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TicketInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_free\0\u{3}entry_fee\0\u{3}early_bird_fee\0\u{3}is_appointment_based\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isFree) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.entryFee) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.earlyBirdFee) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isAppointmentBased) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isFree != false {
      try visitor.visitSingularBoolField(value: self.isFree, fieldNumber: 1)
    }
    if self.entryFee.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.entryFee, fieldNumber: 2)
    }
    if self.earlyBirdFee.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.earlyBirdFee, fieldNumber: 3)
    }
    if self.isAppointmentBased != false {
      try visitor.visitSingularBoolField(value: self.isAppointmentBased, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_TicketInfo, rhs: Eventsease_V1_TicketInfo) -> Bool {
    if lhs.isFree != rhs.isFree {return false}
    if lhs.entryFee != rhs.entryFee {return false}
    if lhs.earlyBirdFee != rhs.earlyBirdFee {return false}
    if lhs.isAppointmentBased != rhs.isAppointmentBased {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_SocialLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SocialLink"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_SocialLink, rhs: Eventsease_V1_SocialLink) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_GetEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0\u{1}categories\0\u{1}date\0\u{3}sort_by\0\u{3}sort_direction\0\u{3}search_query\0\u{3}is_regular\0\u{1}page\0\u{1}limit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._region) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.categories) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.sortBy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.sortDirection) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.searchQuery) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isRegular) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._region {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.categories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categories, fieldNumber: 2)
    }
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 3)
    }
    if self.sortBy != .unspecified {
      try visitor.visitSingularEnumField(value: self.sortBy, fieldNumber: 4)
    }
    if self.sortDirection != .unspecified {
      try visitor.visitSingularEnumField(value: self.sortDirection, fieldNumber: 5)
    }
    if !self.searchQuery.isEmpty {
      try visitor.visitSingularStringField(value: self.searchQuery, fieldNumber: 6)
    }
    if self.isRegular != false {
      try visitor.visitSingularBoolField(value: self.isRegular, fieldNumber: 7)
    }
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 8)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_GetEventsRequest, rhs: Eventsease_V1_GetEventsRequest) -> Bool {
    if lhs._region != rhs._region {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.date != rhs.date {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.sortDirection != rhs.sortDirection {return false}
    if lhs.searchQuery != rhs.searchQuery {return false}
    if lhs.isRegular != rhs.isRegular {return false}
    if lhs.page != rhs.page {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_Region: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Region"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}latitude\0\u{1}longitude\0\u{3}latitude_delta\0\u{3}longitude_delta\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.latitudeDelta) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.longitudeDelta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    if self.latitudeDelta.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.latitudeDelta, fieldNumber: 3)
    }
    if self.longitudeDelta.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.longitudeDelta, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_Region, rhs: Eventsease_V1_Region) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitudeDelta != rhs.latitudeDelta {return false}
    if lhs.longitudeDelta != rhs.longitudeDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_GetEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}data\0\u{1}meta\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_GetEventsResponse, rhs: Eventsease_V1_GetEventsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.data != rhs.data {return false}
    if lhs._meta != rhs._meta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_MetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetaData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}total_count\0\u{3}total_pages\0\u{3}current_page\0\u{1}limit\0\u{3}has_next_page\0\u{3}has_previous_page\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalPages) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.currentPage) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasNextPage_p) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasPreviousPage_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 1)
    }
    if self.totalPages != 0 {
      try visitor.visitSingularInt64Field(value: self.totalPages, fieldNumber: 2)
    }
    if self.currentPage != 0 {
      try visitor.visitSingularInt32Field(value: self.currentPage, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 4)
    }
    if self.hasNextPage_p != false {
      try visitor.visitSingularBoolField(value: self.hasNextPage_p, fieldNumber: 5)
    }
    if self.hasPreviousPage_p != false {
      try visitor.visitSingularBoolField(value: self.hasPreviousPage_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_MetaData, rhs: Eventsease_V1_MetaData) -> Bool {
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.totalPages != rhs.totalPages {return false}
    if lhs.currentPage != rhs.currentPage {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.hasNextPage_p != rhs.hasNextPage_p {return false}
    if lhs.hasPreviousPage_p != rhs.hasPreviousPage_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_GetEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}id_or_slug\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idOrSlug) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idOrSlug.isEmpty {
      try visitor.visitSingularStringField(value: self.idOrSlug, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_GetEventRequest, rhs: Eventsease_V1_GetEventRequest) -> Bool {
    if lhs.idOrSlug != rhs.idOrSlug {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_GetEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_GetEventResponse, rhs: Eventsease_V1_GetEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_CreateEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEventRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}event\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_CreateEventRequest, rhs: Eventsease_V1_CreateEventRequest) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_CreateEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}message\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_CreateEventResponse, rhs: Eventsease_V1_CreateEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_GetEventStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventStatsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_GetEventStatsRequest, rhs: Eventsease_V1_GetEventStatsRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_GetEventStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEventStatsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_GetEventStatsResponse, rhs: Eventsease_V1_GetEventStatsResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_EventStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventStats"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}heart_count\0\u{3}saved_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.heartCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.savedCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.heartCount != 0 {
      try visitor.visitSingularInt32Field(value: self.heartCount, fieldNumber: 1)
    }
    if self.savedCount != 0 {
      try visitor.visitSingularInt32Field(value: self.savedCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_EventStats, rhs: Eventsease_V1_EventStats) -> Bool {
    if lhs.heartCount != rhs.heartCount {return false}
    if lhs.savedCount != rhs.savedCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_GetUserEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserEventsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}page\0\u{1}limit\0\u{3}search_query\0\u{3}sort_by\0\u{3}sort_direction\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.page) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.searchQuery) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.sortBy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.sortDirection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.page != 0 {
      try visitor.visitSingularInt32Field(value: self.page, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.searchQuery.isEmpty {
      try visitor.visitSingularStringField(value: self.searchQuery, fieldNumber: 3)
    }
    if self.sortBy != .unspecified {
      try visitor.visitSingularEnumField(value: self.sortBy, fieldNumber: 4)
    }
    if self.sortDirection != .unspecified {
      try visitor.visitSingularEnumField(value: self.sortDirection, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_GetUserEventsRequest, rhs: Eventsease_V1_GetUserEventsRequest) -> Bool {
    if lhs.page != rhs.page {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.searchQuery != rhs.searchQuery {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.sortDirection != rhs.sortDirection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_ToggleSavedEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToggleSavedEventRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitSingularStringField(value: self.eventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_ToggleSavedEventRequest, rhs: Eventsease_V1_ToggleSavedEventRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eventsease_V1_ToggleSavedEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToggleSavedEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}is_saved\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isSaved) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.isSaved != false {
      try visitor.visitSingularBoolField(value: self.isSaved, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Eventsease_V1_ToggleSavedEventResponse, rhs: Eventsease_V1_ToggleSavedEventResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.isSaved != rhs.isSaved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
